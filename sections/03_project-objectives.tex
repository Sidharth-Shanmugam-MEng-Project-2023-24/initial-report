The system must be able to accurately and reliably pinpoint the location of backscatter particles as well as map out the shape of the outline, enabling the perfect segmentation of each particle for elimination. The work of the previous student on this project \cite{katieshepherdMachineVisionBased2023} outlines the backscatter detection and elimination system revolving around a simple blob detection algorithm. However, much industry-related literature refers to Canny, an edge-detection algorithm, as the industry standard for bubble detection and characterisation for underwater environmental analysis systems. While simple blob detection is a viable method due to computational simplicity, as Shepherd mentions, for blob detection to work, the blobs must share at least one property, such as size or shape, to isolate these blobs. Underwater is a volatile environment where backscatter particles may be unique, so the system must revolve around the Canny algorithm, harnessing enhancements seen in \cite{zelenkaGasBubbleShape2014} for utmost reliability and accuracy.

Despite many highly efficient intellectual property (IP) cores for re-usable FPGA-based logic to accelerate FPGA development, the monumental complexity curve persists due to the requirement of low-level hardware knowledge and familiarity with digital design concepts. Furthermore, FPGAs are, on average, much more expensive than traditional CPU-based computers. It is much easier to harness the simplicity of a CPU-based machine, a high-level programming language such as Python and heavily optimised libraries from OpenCV for rapid development of machine vision applications. Taking a simplistic approach with a non-FPGA system, an RPi 4 or 5 with an RPi Global Shutter camera will drive a DLP projector, utilising the particle centre location and outline mapping to project holes in the light beam in addition to the implementation of position calibration, which is crucial to minimise the parallax effect, the displacement of the target from the perceived position in the video capture, ultimately ensuring accurate backscatter elimination.

Shepherd discusses the hindrance to the successful operation of the blob detection-based backscatter elimination software due to the effects of the Linux operating system (OS): Linux's ability to run tasks in the background while the program is running, interfered with the execution of the program, making the camera image buffer and freeze \cite{katieshepherdMachineVisionBased2023}. Due to the incompatibility of an RPi system with RTOS, the project will still be Linux-driven, though implementing the PREEMPT-RT kernel patch to minimise task switching latencies to mitigate the jitter issues as much as possible experienced by Shepherd. Sacrificing performance for rapid development, Python enables real-time development for less stringent requirements. Research to benchmark the system performance of Python can lead to the development of a C++-based system for low-level optimisation and compliance with even the most rigorous real-time requirements.

Although reducing the resolution of high-quality image frame captures is viable to reduce the computational overheads with machine vision applications, it often trades off object detection and segmentation accuracy. A predictive system approach can mitigate the computationally intensive requirement of machine vision application to every frame of an input video feed. Accurate backscatter particle movement and future location prediction eliminate the requirement to apply machine vision-based technologies to every frame in the video feed to identify and segment the particles. There are two main approaches: (a) an artificial intelligence (AI) approach, harnessing supervised machine learning (ML) methods with a potential to incorporate unsupervised methods for greater accuracy, or (b) a non-AI/ML interpolative approach with an application of either a linear or polynomial interpolation algorithm to predict future positions concerning the tracked locations in a finite count of previous frames. There are significant trade-offs concerning accuracy, speed, and computational overheads for each approach that requires exploration.
